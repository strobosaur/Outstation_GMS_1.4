<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// INIT DISPLAY
    
    // DISPLAY PARAMETERS
    game_width = global.game_width;
    game_height = global.game_height;
    
    display_width = max(1, display_get_width()); // Actual display Width
    display_height = max(1, display_get_height()); // Actual display Height

    shader_ch = 1;
    
//    x_dist = shader_get_uniform(shChromatic, 'x_dist');
//    y_dist = shader_get_uniform(shChromatic, 'y_dist');
    
    x_wave = 0;
    y_wave = 0;
    
    // Aspect ratio
    aspr = max((game_width / game_height), (game_height / game_width)); 
    
    if(game_width &gt; game_height) { wide = true; } // Horizontal view
    if(game_width &lt; game_height) { wide = false; } // Vertical view
    
    xoffs = 0; // VIEW X OFFSET
    yoffs = 0; // VIEW Y OFFSET

    // SCALE STYLE
    
    // 0 = pixel perfect inside display
    // 1 = pixel perfect no letterboxing
    // 2 = keep ratio, touch from inside
    // 3 = keep ratio, touch from outside
    
    init_display(1);
    
    // RESIZE ROOM
    if (room_width &lt; view_wview[0])
    {
        room_width = view_wview[0];
    }
    
    if (room_height &lt; view_hview)
    {
        room_height = view_hview[0];
    }
    
    // SET ROOM VIEW
    for(var i = 1; i &lt;= room_last; i++)
    {
        if room_exists(i)
        {
            room_set_view(i, 0, true, 0, 0, game_width, game_height, 0, 0, game_width, game_height, 0, 0, 0, 0, -1);
            room_set_view_enabled(i, true);
        }
    }
    
    // STATS HUD
    statshud = false;
    colhue = 0;
    colhue2 = 0;
    col2 = 0;
    fpshud = fps_real;
    alarm[0] = 3;
    
    shader_surf = surface_create(game_width, game_height);
    
    // MAKE PERSISTENT
    
    if !persistent {persistent = true;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// INIT SHADER PARAMETERS

    sh_wavelen = 2.5;
    sh_wavelen_mod = 0;
    sh_jitterlen = 1.25;
    sh_jitterlen_mod = 0;
    sh_jitter_wave_mix = 0.4;
    sh_jitter_wave_mix_mod = 0;
    sh_saturation = 0.95;
    sh_saturation_mod = 0;
    sh_contrast = 0.4//0.1;
    sh_contrast_mod = 0;
    
    sh_sat_boom_mod = 0;
    sh_con_boom__mod = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ALARM FPS

    fpshud = fps_real;
    alarm[0] = 5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// MODIFY SCREEN SCALING

    // CHECK FOR INPUT
    
/*    if (keyboard_check_pressed(vk_f1))
    {
        scale = screenscaler(0); // STYLE 1
    }
    
    if (keyboard_check_pressed(vk_f2))
    {
        scale = screenscaler(1); // STYLE 2
    }
    
    if (keyboard_check_pressed(vk_f3))
    {
        scale = screenscaler(2); // STYLE 3
    }
    
    if (keyboard_check_pressed(vk_f4))
    {
        scale = screenscaler(3); // STYLE 4
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DISPLAY STATS

    colhue = (colhue + 0.1) mod 255;
    if colhue2 &gt; 0
    {
        colhue2 = colhue2 - (3+random(1));
    } else {
        colhue2 += 255;
    }
    
    if keyboard_check_pressed(vk_f5){statshud = !statshud;}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// SHADER POSITION &amp; MIXING

    var wavemod = pulse_mid(0.025, 0.0235, 0.24);
    x_wave1 = pulse_mid(0.022 + wavemod, 2, 0);    
    y_wave1 = pulse_mid(0.075 + wavemod, 2, 0);

/*    var wavemod2 = pulse_mid(0.0125, 0.35, 0.25);
    x_wave2 = pulse_mid(0.0042 + wavemod2, 2, 0);    
    y_wave2 = pulse_mid(0.0095 + wavemod2, 2, 0);*/
    
    var wavemod2 = pulse_mid(0.125, 0.25, 0.5);
    x_wave2 = pulse_mid(0.0042 + wavemod2, 2, 0);    
    y_wave2 = pulse_mid(0.0095 + wavemod2, 2, 0);

    var wavemod3 = pulse_mid(0.05, 0.125 / (0.5 * wavemod), 0.2);
    mix_wave_x = pulse_mid(0.002 + wavemod3, 0.1, 2.5);    
    mix_wave_y = pulse_mid(0.095, 2, 1 + wavemod2);
    
    // MIXING ETC    
    sh_wavelen_mod *= 0.65 //0.85;
    sh_jitterlen_mod *= 0.65 //0.85;
    sh_saturation_mod *= 0.9;
    sh_contrast_mod *= 0.9;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// RENDER APPLICATION SURFACE

    var surface_scale = scale;
    
    window_set_fullscreen(global.fullscreen);

    // IF WINDOWED, CENTER POSITION
    if window_get_fullscreen() == false
    {
        surface_scale = scale-1;
        
        var xpos = (display_get_width() - (game_width * surface_scale)) / 2;
        var ypos = (display_get_height() - (game_height * surface_scale)) / 2;
        
        window_set_size(game_width * surface_scale, game_height * surface_scale);
//        surface_resize(application_surface, game_width * (scale-1), game_height * (scale-1));
//        window_set_position(xpos, ypos);
        window_center()
    }
    
    // CHROMATIC ABBERATION SHADER
    if shader_ch == 1
    {
        /// SHADER
        shader_set(shChromatic);
        
        // GAUSSIAN BLUR
//        var gblur = shader_get_uniform(shChromatic, 'gblur1');
        
        var u_chaos1 = shader_get_uniform(shChromatic, 'chaos1');
        // X &amp; Y DIST
        var x_dist = shader_get_uniform(shChromatic, 'x_dist');
        var y_dist = shader_get_uniform(shChromatic, 'y_dist');
        // R &amp; GB SHEETS INDIVIDUAL DISTANCE
        var r_dist = shader_get_uniform(shChromatic, 'r_dist');
        var gb_dist = shader_get_uniform(shChromatic, 'gb_dist');
        // CONTRAST
        var u_con = shader_get_uniform(shChromatic, 'contrast1');
        // SATURATION
        var u_sat = shader_get_uniform(shChromatic, 'saturation1');
        // CHAOS
        var chaos1 = random(2);
        
        // JITTERS MOD
        var rdir = random(360);
        var rlen = rnd(0.75, 0.25) * (sh_jitterlen + sh_jitterlen_mod);
        var wavemod = pulse_mid(0.75, 0.25, sh_jitter_wave_mix);
        var conwave = pulse_mid(0.25, 0.25, sh_contrast); //0.1, 
        
        // WAVE &amp; JITTERS MIX
        var wavelen = sh_wavelen + sh_wavelen_mod;
        x_wave1 = lerp(lengthdir_x(rlen, rdir), x_wave1 * wavelen, wavemod);
        y_wave1 = lerp(lengthdir_y(rlen, rdir), y_wave1 * wavelen, wavemod);
        
        // CONTRAST
        var con = sh_contrast + conwave + sh_contrast_mod;
        // SATURATION
        var sat = sh_saturation + sh_saturation_mod;
        
        // PASS HANDLES
        shader_set_uniform_f(u_chaos1, mix_wave_x);
        // PASS HANDLES X &amp; Y
        shader_set_uniform_f(x_dist, x_wave1);
        shader_set_uniform_f(y_dist, y_wave1);
        shader_set_uniform_f(r_dist, rnd(0.75, 0.25));
        shader_set_uniform_f(gb_dist, rnd(0.75, 0.25));
        // PASS HANDLES SATURATION
        shader_set_uniform_f(u_sat, sat);
        shader_set_uniform_f(u_con, con);
        // PASS GAUSSIAN BLUR HANDLES
//        shader_set_uniform_f(gblur, 0.0001, 0.0001, 0.0001);
    
        // RENDER SURFACE ==========================
        
        draw_surface_ext(
        application_surface, 
        xoffs, 
        yoffs, 
        surface_scale, 
        surface_scale, 
        0, c_white, 1);
        
        shader_reset();
    }
    else
    {    
        // Render resized application surface
        draw_surface_ext(
        application_surface, 
        xoffs, 
        yoffs, 
        surface_scale, 
        surface_scale, 
        0, c_white, 1);
    }    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// SHADER SURF

    
/*    if surface_exists(shader_surf)
    {
        application_surface_draw_enable(false);
        surface_copy(shader_surf,0,0,application_surface);
        
        shader_set(shBloom);
        
        surface_set_target(shader_surf);
        var u_thresh = shader_get_uniform(shBloom, 'u_threshold');
        var u_radius = shader_get_uniform(shBloom, 'u_radius');
        var u_amount = shader_get_uniform(shBloom, 'u_amount');
        
        var thresh = pulse_mid(0.5, 10, 10);
        var radius = pulse_mid(0.4, 10, 10);
        var amount = pulse_mid(0.3, 10, 10);
        
        shader_set_uniform_f(u_thresh, thresh);
        shader_set_uniform_f(u_radius, radius);
        shader_set_uniform_f(u_amount, amount);
        
        draw_surface_ext(
        shader_surf, 
        xoffs, 
        yoffs, 
        scale, 
        scale, 
        0, c_white, 1);
        
        surface_reset_target();
        shader_reset();
    }
    else
    {
        shader_surf = surface_create(game_width, game_height);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
