<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// INIT PROP LIST &amp;&amp; ROOM POOL

    room_pool = ds_list_create();
//    big_rooms = ds_list_create();
    grid_debug = false;

    init_roompool(room_pool);

    proplist = ds_list_create();
    
//    repeat(1) {ds_list_add(proplist, sRock01); }
//    repeat(1) {ds_list_add(proplist, sRock02); }
    repeat(1) {ds_list_add(proplist, sRock03); }
//    repeat(0) {ds_list_add(proplist, sRock04); }
//    repeat(1) {ds_list_add(proplist, sGraves01); }
    repeat(4) {ds_list_add(proplist, sBones01); }
    repeat(10) {ds_list_add(proplist, sHgrass01); }
    repeat(15) {ds_list_add(proplist, sGrass01); }
    repeat(15) {ds_list_add(proplist, sGrass02); }
    repeat(15) {ds_list_add(proplist, sGrass03); }
    repeat(15) {ds_list_add(proplist, sGrass04); }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// MAKE MAP

    global.start_x1 = 0;
    global.start_y1 = 0;

    global.start_x2 = 0;
    global.start_y2 = 0;

    var mapw = 160;
    var maph = 160;
    
    var cell_factor = 3;
    
    var gridw = mapw div cell_factor;
    var gridh = maph div cell_factor;
    
    start_door = 0;
    
//    background
    
//    room_set_background_colour(room,c_black,true);
    
    room_width = mapw * CELL;
    room_height = maph * CELL;

    // LEVEL GENERATOR GRID
    big_room_grid = ds_grid_create(gridw, gridh);
    ds_grid_clear(big_room_grid, mapcode.void);
    
    // FINAL MAP GRID
    mapgrid = ds_grid_create(mapw, maph);
    ds_grid_clear(mapgrid, 0);
    grid_surf = surface_create(ds_grid_width(mapgrid), ds_grid_height(mapgrid));
    
    // PATHGRID
    global.pathgrid = mp_grid_create(0,0,gridw, gridh, CELL*cell_factor, CELL*cell_factor);
    
    // COLLISION GRID
    global.collision_grid = ds_grid_create(mapw, maph);
    ds_grid_clear(global.collision_grid, 0);
    // BULLET GRID
    global.bullet_grid = ds_grid_create(mapw, maph);
    ds_grid_clear(global.bullet_grid, 0);
    
    // GENERATE LEVEL
//    level_generator(big_room_grid, 4, 0);
    level_generator2(big_room_grid);
    
    // COMPACTIFY
//    room_grid_make_compact(big_room_grid, mapcode.void);
    
    // MARK IN PATH GRID
    mp_grid_marker(big_room_grid)
    
    // MAGNIFY GRID
    grid_magnifier(big_room_grid, mapgrid, cell_factor);
    place_map_door_objects(door_list,cell_factor);
    
    tiles_wall_cleaner(mapgrid);
    
    // REMAP WALLS &amp; VOID
//    remap_tiletype(mapgrid, mapcode.wall, mapcode.hole);
    remap_tiletype_if_prox(mapgrid, mapcode.void, mapcode.wall);
    
    // REMAP WALL 2
    remap_tiletype(mapgrid, mapcode.wall2, mapcode.wall);
    remap_tiletype(mapgrid, mapcode.walkway, mapcode.ground);
    
    // MARK COLLISION GRID
    collision_grid_marker(mapgrid, global.collision_grid, mapcode.wall);
    collision_grid_marker(mapgrid, global.collision_grid, mapcode.hole);
    collision_grid_marker(mapgrid, global.collision_grid, mapcode.void);
    // MARK BULLET GRID
    bullet_grid_marker(mapgrid, global.bullet_grid, mapcode.wall);
    bullet_grid_marker(mapgrid, global.bullet_grid, mapcode.void);
    
    midx = room_width div 2;
    midy = room_height div 2;
    
//    ds_grid_clear(mapgrid, tiletype.GRASS01);
    
//    tile_digger(mapgrid, mapw div 2, maph div 2, 0.75, tiletype.STONE01, 0, 96, 16);
//    tile_blob_digger(mapgrid, mapw div 2, maph div 2, 0.75, 2, 0.2, tiletype.GRASS02, 2, 16, 12);
    
//    tiler(mapgrid, CELL, tiletype.STONE01, 1, bg_stones16, 0, 0, 101);

    tiles_wall_cleaner(mapgrid);
    
    tiler(mapgrid, CELL, mapcode.ground, 0.05, bg_grass01b, 0, 0, 100);
    tiler(mapgrid, CELL, mapcode.wall2, 0.05, bg_grass01b, 0, 0, 100);
    tiler(mapgrid, CELL, mapcode.door, 0.05, bg_grass01b, 0, 0, 100);
    tiler(mapgrid, CELL, mapcode.room_center, 0.05, bg_grass01b, 0, 0, 100);
    tiler(mapgrid, CELL, mapcode.passage, 0.1, bg_dark16, 0, 0, 100);
    
    tiles_cliff_depth(mapgrid, mapcode.wall, mapcode.ground, bg_cliff03b);
    tiles_cliff_depth(mapgrid, mapcode.hole, mapcode.ground, bg_cliff03b);
    tiles_cliff_depth(mapgrid, mapcode.hole, mapcode.wall, bg_cliff03b);
    
    // PLATES
    tiles_plates_depth(mapgrid, mapcode.ground, mapcode.wall, bg_cliff03b);
    tiles_plates_depth(mapgrid, mapcode.door, mapcode.wall, bg_cliff03b);
    tiles_plates_depth(mapgrid, mapcode.hole, mapcode.wall, bg_cliff03b);
    tiles_plates_top(mapgrid, mapcode.wall, mapcode.wall, bg_plates02_top);
//    tiles_plates_top(mapgrid, mapcode.wall2, mapcode.wall, bg_plates01_top);

    // GRASS TILE / EDGE TILES
    tiles_grass_ledge2(mapgrid, mapcode.ground, mapcode.ground, bg_grass_ledge01b);
    tiles_grass_ledge(mapgrid, mapcode.ground, mapcode.wall, bg_grass_ledge01);
    
    // DOOR TILE &amp; GRASS EDGES &amp; BRIDGE
    
    tiles_grass_ledge2(mapgrid, mapcode.door, mapcode.ground, bg_grass_ledge01b);
    tiles_grass_ledge(mapgrid, mapcode.door, mapcode.wall, bg_grass_ledge01);
    
    tiles_grass_ledge2(mapgrid, mapcode.passage, mapcode.ground, bg_grass_ledge01b);
    tiles_grass_ledge(mapgrid, mapcode.passage, mapcode.wall, bg_grass_ledge01);
    
    tiles_underside(mapgrid, mapcode.door, mapcode.hole, bg_bridge01);
    tiles_underside(mapgrid, mapcode.passage, mapcode.hole, bg_bridge01);
    
    // PROPS
    tiler_props(mapgrid, mapcode.ground, CELL, oProp, 0.25);
    
    global.start_x1 = ((global.start_x1) * cell_factor * CELL) + (cell_factor * CELL / 2);
    global.start_y1 = ((global.start_y1) * cell_factor * CELL) + (cell_factor * CELL / 2);
    
    global.start_x2 = ((global.start_x2) * cell_factor * CELL) + (cell_factor * CELL / 2);
    global.start_y2 = ((global.start_y2) * cell_factor * CELL) + (cell_factor * CELL / 2);
    
    global.start_x = (global.start_x * cell_factor * CELL) + (cell_factor*CELL / 2);
    global.start_y = (global.start_y * cell_factor * CELL) + (cell_factor*CELL / 2);
    
//    fast_edge_tiler(mapgrid, tiletype.GRASS02, tiletype.GRASS01, bg_grass02_edges01, 99);
//    tiler(mapgrid, CELL, tiletype.GRASS02, 0, bg_grass02_edges01, 16, 16, 98);

    // CREATE PROPS
//    instance_create(midx, midy, oPropspawn);
    // CREATE BASE
    
    // CREATE LEADER
    with instance_create(global.start_x, global.start_y, oDroid)
    {
       state = idle_state;
       global.leader = id;
    }
    ///CREATE CAMERA
    if !instance_exists(camera)
    {
        with instance_create(0, 0, camera) //room_width div 2, room_height div 2, camera);
        {
            target[? "x"] = other.midx;
            target[? "y"] = other.midy;
        }
    }
    
    ds_list_destroy(room_mid_list);
    ds_grid_destroy(big_room_grid);
    ds_list_destroy(room_pool);
        
    ds_list_destroy(open_ends);
    ds_list_destroy(local_open_ends);
    ds_list_destroy(door_list);
    
    while !ds_list_empty(room_map_list)
    {
        ds_map_destroy(ds_list_find_value(room_map_list, 0));
        ds_list_delete(room_map_list, 0);
    }
    
    ds_list_destroy(room_map_list);
    
/*    ds_grid_destroy(grid02);
    ds_grid_destroy(tilegrid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CLEANUP DS

    ds_grid_destroy(mapgrid);
    ds_grid_destroy(global.bullet_grid);
    ds_list_destroy(proplist);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DRAW MP GRID

    if global.draw_paths
    {
        draw_set_colour(c_white);
        draw_set_alpha(0.1);
        mp_grid_draw(global.pathgrid);
        draw_set_alpha(1);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*if grid_debug = true
{
    var grw = ds_grid_width(big_rooms)
    var grh = ds_grid_height(big_rooms)
    
    if !surface_exists(grid_surf)
    {
        grid_surf = surface_create(ds_grid_width(big_rooms), ds_grid_height(big_rooms));
    }
    else
    {
        surface_set_target(grid_surf);
        ds_grid_draw(big_rooms, 0, 0);
       draw_surface_ext(grid_surf, 0, 0, window_get_width() / grw, window_get_height() / grh, 0, c_white, 1);
    }
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
